#!/usr/bin/env bash
#
# Author: Antoine de Lagrave
# Email: antoinedelagrave@hotmail.com
# GitHub: @BCarnaval
#
# This script was generated by bashly 1.0.5 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
dvmc_usage() {
  if [[ -n $long_usage ]]; then
    printf "dvmc - Command line tool to perform dynamical variationnal Monte Carlo calculations\n"
    echo

  else
    printf "dvmc - Command line tool to perform dynamical variationnal Monte Carlo calculations\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  dvmc COMMAND\n"
  printf "  dvmc [COMMAND] --help | -h\n"
  printf "  dvmc --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Evaluates the ground state using dynamical variationnal Monte Carlo (dVMC)\n" "$(green "groundstate")   "
  printf "  %s   Generates all '.def' input files needed based on a global parameters input\n" "$(green "generate")      "
  printf "  %s   Proceeds to dynamical calculations using 'namelist_G.def'\n" "$(green "excitations")   "
  printf "  %s   Merge binary output files\n" "$(green "process-output")"
  printf "  %s   Q-matrix calcultations\n" "$(green "qmatrix")       "
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "$(magenta "--version, -v")"
    printf "    Show version number\n"
    echo

    # :command.usage_environment_variables
    printf "%s\n" "$(bold "Environment Variables:")"

    # :environment_variable.usage
    printf "  %s\n" "$(cyan "DVMC_SCRIPTS_LOCATION")"
    printf "    Sets the default directory in which dVMC tools are located\n"
    printf "    Default: $HOME/.local/share/dvmc\n"
    echo

    # :environment_variable.usage
    printf "  %s\n" "$(cyan "DVMC_MPI_PROC")"
    printf "    Sets the number of processors (CPUS) to use within the MPI call.\n"
    printf "    Default: 1\n"
    echo

  fi
}

# :command.usage
dvmc_groundstate_usage() {
  if [[ -n $long_usage ]]; then
    printf "dvmc groundstate - Evaluates the ground state using dynamical variationnal Monte Carlo (dVMC)\n"
    echo

  else
    printf "dvmc groundstate - Evaluates the ground state using dynamical variationnal Monte Carlo (dVMC)\n"
    echo

  fi

  printf "Alias: gs\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  dvmc groundstate NAMELIST [OPTIMIZED]\n"
  printf "  dvmc groundstate --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "NAMELIST")"
    printf "    Specifies configurations files to dVMC binary\n    \n    Basic parameters\n    - modpara.def       -> basic parameters for calculations\n    - locspn.def        -> locations of local spins\n    \n    Hamiltonian\n    - trans.def         -> transfer integrals\n    - coulombintra.def  -> on-site Coulomb interactions (U_i)\n    - coulombinter.def  -> inter-site Coulomb interactions (V_{ij})\n    - hund.def          -> J_{ij}^{Hund} in H_H hamiltonian\n    - exchange.def      -> J_{ij}^{Ex} in H_E hamiltonian\n    \n    Variationnal parameters\n    - gutzwilleridx.def -> gutzwiller correlation factors (g_i)\n    - jastrowidx.def    -> jastrow correlation factors (v_{ij})\n    - orbitalidx.def    -> anti-parallel Pfaffian wave functions\n    - qptransidx.def    -> momentum and point-group projections\n"
    echo

    # :argument.usage
    printf "  %s\n" "$(blue "OPTIMIZED")"
    printf "    Specifies the path to 'zqp_opt.dat' file in which the binary finds optimized\n    dynamical parameters coefficients to proceed his calculations.\n"
    echo

    # :command.usage_examples
    printf "%s\n" "$(bold "Examples:")"
    printf "  dvmc groundstate ./namelist.def\n"
    printf "  dvmc gs ./namelist.def\n"
    echo

  fi
}

# :command.usage
dvmc_generate_usage() {
  if [[ -n $long_usage ]]; then
    printf "dvmc generate - Generates all '.def' input files needed based on a global parameters input\n"
    echo

  else
    printf "dvmc generate - Generates all '.def' input files needed based on a global parameters input\n"
    echo

  fi

  printf "Alias: gen\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  dvmc generate PARAMETERS_FILE [HOPPING_OPTION]\n"
  printf "  dvmc generate --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "PARAMETERS_FILE")"
    printf "    Input parameters text file to be parsed defining system caracteristics.\n    The file must be formatted the following way\n    \n                       [param_name_1] [param_value_1]\n                       [param_name_2] [param_value_2]\n                                     .\n                                     .\n                                     .\n"
    echo

    # :argument.usage
    printf "  %s\n" "$(blue "HOPPING_OPTION")"
    printf "    Generating 'excitation.def' file using options (1, 2 or 3). The first option\n    calls 'makeExcitation.py', the second 'makeExcitation_from_hopping.py' and\n    the third 'makeExcitation_from_hopping_only_t.py'. Those are respectively #\n    TODO Add description\n"
    echo

    # :command.usage_examples
    printf "%s\n" "$(bold "Examples:")"
    printf "  dvmc generate parameters.txt 1\n"
    printf "  dvmc gen params 3\n"
    echo

  fi
}

# :command.usage
dvmc_excitations_usage() {
  if [[ -n $long_usage ]]; then
    printf "dvmc excitations - Proceeds to dynamical calculations using 'namelist_G.def'\n"
    echo

  else
    printf "dvmc excitations - Proceeds to dynamical calculations using 'namelist_G.def'\n"
    echo

  fi

  printf "Alias: excs\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  dvmc excitations NAMELIST OPTIMIZED\n"
  printf "  dvmc excitations --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "NAMELIST")"
    printf "    Specifies the configuration files to dVMC dynamical binary.\n"
    echo

    # :argument.usage
    printf "  %s\n" "$(blue "OPTIMIZED")"
    printf "    Specifies the path to 'zqp_opt.dat' file in which the binary finds optimized\n    dynamical parameters coefficients to proceed his calculations.\n"
    echo

    # :command.usage_examples
    printf "%s\n" "$(bold "Examples:")"
    printf "  dvmc excitations namelist_G.def output/zqp_opt.dat\n"
    printf "  dvmc excs namelist_G.def output/zqp_opt.dat\n"
    echo

  fi
}

# :command.usage
dvmc_process_output_usage() {
  if [[ -n $long_usage ]]; then
    printf "dvmc process-output - Merge binary output files\n"
    echo

  else
    printf "dvmc process-output - Merge binary output files\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  dvmc process-output PREFIX\n"
  printf "  dvmc process-output --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "PREFIX")"
    printf "    Prefix of all the input files to be process and save in './output'\n    directory. The command uses this prefix to grep all of the prefix*bin\n    files and process them.\n"
    echo

    # :command.usage_examples
    printf "%s\n" "$(bold "Examples:")"
    printf "  dvmc process-output ./output/zvo_nCHAm_nAHCm_0*bin\n"
    echo

  fi
}

# :command.usage
dvmc_qmatrix_usage() {
  if [[ -n $long_usage ]]; then
    printf "dvmc qmatrix - Q-matrix calcultations\n"
    echo

  else
    printf "dvmc qmatrix - Q-matrix calcultations\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  dvmc qmatrix PROCESSING TOLERANCE USE_FILTER ADDTL_FILTER [K_TOLERANCE]\n"
  printf "  dvmc qmatrix --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "PROCESSING")"
    printf "    Type of processing to do on the Q-matrix. Either 'cond',\n    'svd' or 'sqrt' or empty argument for basic processing\n"
    echo

    # :argument.usage
    printf "  %s\n" "$(blue "TOLERANCE")"
    printf "    Specific tolerance that determines the number of states kept for the\n    calculations of the Q-matrix. The default value is 1e-10\n"
    echo

    # :argument.usage
    printf "  %s\n" "$(blue "USE_FILTER")"
    printf "    If set, modifies the number of states kept for the Q-matrix calculations.\n"
    echo

    # :argument.usage
    printf "  %s\n" "$(blue "ADDTL_FILTER")"
    printf "    Modifies the default value for the filter, which is 0.9.\n"
    echo

    # :argument.usage
    printf "  %s\n" "$(blue "K_TOLERANCE")"
    printf "    Modifies the Q-matrix calculations in the 'svd' processing case\n"
    echo

    # :command.usage_examples
    printf "%s\n" "$(bold "Examples:")"
    printf "  dvmc qmatrix sqrt 0.75 1 0.9\n"
    printf "  dvmc qmatrix svd 0.75 1 0.9 0.8\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do echo "- \${deps[$k]} = ${deps[$k]}"; done
  fi

}

# :command.user_lib
# src/lib/colors.sh
print_in_color() {
  local color="$1"
  shift
  if [[ -z ${NO_COLOR+x} ]]; then
    printf "$color%b\e[0m\n" "$*"
  else
    printf "%b\n" "$*"
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }
red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }

# :command.command_functions
# :command.function
dvmc_groundstate_command() {
  # src/groundstate_command.sh
  # Ground state command script

  run_dvmc () {
    # Constants
    N_PROC="${DVMC_MPI_PROC}"
    NAMELIST="${args[namelist]}"
    OPTIMIZED="${args[optimized]}"

    # Script
    if [ $(basename "${NAMELIST}") == 'namelist.def' ] && [ -f "${NAMELIST}" ]; then
      green "[@] Static ground state numerical evaluation..."
      if [ -z "${OPTMIZED}" ]; then
        mpirun -n "${N_PROC}" "${DVMC_SCRIPTS_LOCATION}"/dvmc.out "${NAMELIST}"
      else
        green "[@] Using optimized parameters stored in '${OPTIMIZED}'"
        mpirun -n "${N_PROC}" "${DVMC_SCRIPTS_LOCATION}"/dvmc.out "${NAMELIST}" "${OPTMIZED}"
      fi
    else
      red "[X] Input must be a file named: 'namelist.def'."
      exit 1
    fi
  }

  run_dvmc

}

# :command.function
dvmc_generate_command() {
  # src/generate_command.sh
  # Generate command script

  generate () {
    # Generating global .def files
    PARAMS="${args[parameters_file]}"
    if [ -f "${PARAMS}" ]; then
      green "[@] Generating .def files..."
      "${DVMC_SCRIPTS_LOCATION}"/init_params.py "${PARAMS}"
    else
      red "[X] Input must be a file."
      exit 1
    fi

    # Generating excitation.def file
    if [ -z "${args[hopping_option]}" ]; then
      yellow "[!] Skipping excitation.def"
    elif [ "${args[hopping_option]}" == 1 ]; then
      green "[@] Using 'makeExcitation.py' to generate excitation.def"
      "${DVMC_SCRIPTS_LOCATION}"/makeExcitation.py

    elif [ "${args[hopping_option]}" == 2 ]; then
      green "[@] Using 'makeExcitation_from_hopping.py' to generate excitation.def"
      "${DVMC_SCRIPTS_LOCATION}"/makeExcitation_from_hopping.py

    elif [ "${args[hopping_option]}" == 3 ]; then
      green "[@] Using 'makeExcitation_from_hopping_only_t.py' to generate excitation.def"
      "${DVMC_SCRIPTS_LOCATION}"/makeExcitation_from_hopping_only_t.py
    fi
    green "[@] .def files generated."
  }

  generate

}

# :command.function
dvmc_excitations_command() {
  # src/excitations_command.sh
  # Excitations command script

  excitations () {
    # Constants
    N_PROC="${DVMC_MPI_PROC}"
    OPTIMIZED="${args[optimized]}"
    NAMELIST="${args[namelist]}"

    # Script
    if [ $(basename "${NAMELIST}") == 'namelist_G.def' ] && [ -f "${NAMELIST}" ]; then
      green "[@] Beginning dynamical VMC calculations..."
      mpirun -n "${N_PROC}" "${DVMC_SCRIPTS_LOCATION}"/dvmc.out "${NAMELIST}" "${OPTIMIZED}"
    else
      red "[X] Input must be a file named: 'namelist_G.def'."
      exit 1
    fi
  }

  excitations

}

# :command.function
dvmc_process_output_command() {
  # src/process_output_command.sh
  # Process-output command script

  process_output () {
    PREFIX="${args[prefix]}"
    green "[@] Processing ${PREFIX}*bin files..."
    "${DVMC_SCRIPTS_LOCATION}"/mergeOutputBin.py "${PREFIX}"*bin
  }

  process_output

}

# :command.function
dvmc_qmatrix_command() {
  # src/qmatrix_command.sh
  # Q-matrix command script

  q_matrix () {
    # Constants
    PROCESS="${args[processing]}"
    TOL="${args[tolerance]}"
    USE_FILTER="${args[use_filter]}"
    TL_FILTER="${args[addtl_filter]}"
    K_TOL="${args[k_tolerance]}"

    # Script
    if [ "${PROCESS}" == "cond" ]; then
      SCRIPT=dvmc_spectrum_w_cond_number.py
    elif [ "${PROCESS}" == "svd" ]; then
      SCRIPT=dvmc_spectrum_w_SVD.py
    elif [ "${PROCESS}" == "sqrt" ]; then
      SCRIPT=dvmc_spectrum_eigh_w_sqrtS.py
    elif [ -z "${PROCESS}" ]; then
      SCRIPT=dvmc_spectrum.py
    else
      red "[X] The option: '${PROCESS}' isn't supported. Exiting..."
      exit 1
    fi

    green "[@] Computing green function using Q-matrix using script: ${SCRIPT}..."
    if [ -z "${K_TOL}" ]; then
      "${DVMC_SCRIPTS_LOCATION}"/"${SCRIPT}" spectrumpara.def output "${TOL}" "${USE_FILTER}" "${TL_FILTER}"
    else
      "${DVMC_SCRIPTS_LOCATION}"/"${SCRIPT}" spectrumpara.def output "${TOL}" "${USE_FILTER}" "${TL_FILTER}" "${K_TOL}"
    fi
    green "[@] Green's function calculations done."
  }

  q_matrix

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        dvmc_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.environment_variables_filter
  # :command.environment_variables_default
  export DVMC_SCRIPTS_LOCATION="${DVMC_SCRIPTS_LOCATION:-$HOME/.local/share/dvmc}"
  export DVMC_MPI_PROC="${DVMC_MPI_PROC:-1}"

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    groundstate | gs)
      action="groundstate"
      shift
      dvmc_groundstate_parse_requirements "$@"
      shift $#
      ;;

    generate | gen)
      action="generate"
      shift
      dvmc_generate_parse_requirements "$@"
      shift $#
      ;;

    excitations | excs)
      action="excitations"
      shift
      dvmc_excitations_parse_requirements "$@"
      shift $#
      ;;

    process-output)
      action="process-output"
      shift
      dvmc_process_output_parse_requirements "$@"
      shift $#
      ;;

    qmatrix)
      action="qmatrix"
      shift
      dvmc_qmatrix_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      dvmc_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
dvmc_groundstate_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        dvmc_groundstate_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="groundstate"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['namelist']+x} ]]; then

          args['namelist']=$1
          shift
        elif [[ -z ${args['optimized']+x} ]]; then

          args['optimized']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['namelist']+x} ]]; then
    printf "missing required argument: NAMELIST\nusage: dvmc groundstate NAMELIST [OPTIMIZED]\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
dvmc_generate_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        dvmc_generate_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="generate"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['parameters_file']+x} ]]; then

          args['parameters_file']=$1
          shift
        elif [[ -z ${args['hopping_option']+x} ]]; then

          args['hopping_option']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['parameters_file']+x} ]]; then
    printf "missing required argument: PARAMETERS_FILE\nusage: dvmc generate PARAMETERS_FILE [HOPPING_OPTION]\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
dvmc_excitations_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        dvmc_excitations_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="excitations"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['namelist']+x} ]]; then

          args['namelist']=$1
          shift
        elif [[ -z ${args['optimized']+x} ]]; then

          args['optimized']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['namelist']+x} ]]; then
    printf "missing required argument: NAMELIST\nusage: dvmc excitations NAMELIST OPTIMIZED\n" >&2
    exit 1
  fi
  if [[ -z ${args['optimized']+x} ]]; then
    printf "missing required argument: OPTIMIZED\nusage: dvmc excitations NAMELIST OPTIMIZED\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
dvmc_process_output_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        dvmc_process_output_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="process-output"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['prefix']+x} ]]; then

          args['prefix']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['prefix']+x} ]]; then
    printf "missing required argument: PREFIX\nusage: dvmc process-output PREFIX\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
dvmc_qmatrix_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        dvmc_qmatrix_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="qmatrix"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['processing']+x} ]]; then

          args['processing']=$1
          shift
        elif [[ -z ${args['tolerance']+x} ]]; then

          args['tolerance']=$1
          shift
        elif [[ -z ${args['use_filter']+x} ]]; then

          args['use_filter']=$1
          shift
        elif [[ -z ${args['addtl_filter']+x} ]]; then

          args['addtl_filter']=$1
          shift
        elif [[ -z ${args['k_tolerance']+x} ]]; then

          args['k_tolerance']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['processing']+x} ]]; then
    printf "missing required argument: PROCESSING\nusage: dvmc qmatrix PROCESSING TOLERANCE USE_FILTER ADDTL_FILTER [K_TOLERANCE]\n" >&2
    exit 1
  fi
  if [[ -z ${args['tolerance']+x} ]]; then
    printf "missing required argument: TOLERANCE\nusage: dvmc qmatrix PROCESSING TOLERANCE USE_FILTER ADDTL_FILTER [K_TOLERANCE]\n" >&2
    exit 1
  fi
  if [[ -z ${args['use_filter']+x} ]]; then
    printf "missing required argument: USE_FILTER\nusage: dvmc qmatrix PROCESSING TOLERANCE USE_FILTER ADDTL_FILTER [K_TOLERANCE]\n" >&2
    exit 1
  fi
  if [[ -z ${args['addtl_filter']+x} ]]; then
    printf "missing required argument: ADDTL_FILTER\nusage: dvmc qmatrix PROCESSING TOLERANCE USE_FILTER ADDTL_FILTER [K_TOLERANCE]\n" >&2
    exit 1
  fi

}

# :command.initialize
initialize() {
  version="0.1.0"
  long_usage=''
  set -e

  # :command.environment_variables_default
  export DVMC_SCRIPTS_LOCATION="${DVMC_SCRIPTS_LOCATION:-$HOME/.local/share/dvmc}"
  export DVMC_MPI_PROC="${DVMC_MPI_PROC:-1}"

}

# :command.run
run() {
  declare -A args=()
  declare -A deps=()
  declare -a other_args=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "groundstate") dvmc_groundstate_command ;;
    "generate") dvmc_generate_command ;;
    "excitations") dvmc_excitations_command ;;
    "process-output") dvmc_process_output_command ;;
    "qmatrix") dvmc_qmatrix_command ;;
  esac
}

initialize
run "$@"
